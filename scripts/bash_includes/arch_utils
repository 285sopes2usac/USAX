#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-2-Clause

ARCH_VARS_LIST=()
ARCH_VARS_LIST+=(SHORT)
ARCH_VARS_LIST+=(FAMILY)
ARCH_VARS_LIST+=(ELF_NAME)
ARCH_VARS_LIST+=(LD_OUTPUT)
ARCH_VARS_LIST+=(EFI)
ARCH_VARS_LIST+=(GCC_TC)
ARCH_VARS_LIST+=(GCC_FLAGS)

i386_ARCH_SHORT="x86"
i386_ARCH_FAMILY="generic_x86"
i386_ARCH_ELF_NAME="elf32-i386"
i386_ARCH_LD_OUTPUT="elf_i386"
i386_ARCH_EFI="ia32"
i386_ARCH_GCC_TC="i686"
i386_ARCH_GCC_FLAGS="-march=i686"

x86_64_ARCH_SHORT="x86_64"
x86_64_ARCH_FAMILY="generic_x86"
x86_64_ARCH_ELF_NAME="elf64-x86-64"
x86_64_ARCH_LD_OUTPUT="elf_x86_64"
x86_64_ARCH_EFI="x86_64"
x86_64_ARCH_GCC_TC="x86_64"
x86_64_ARCH_GCC_FLAGS=""

riscv64_ARCH_SHORT="riscv64"
riscv64_ARCH_FAMILY="riscv"
riscv64_ARCH_ELF_NAME="elf64-littleriscv"
riscv64_ARCH_LD_OUTPUT="elf64lriscv"
riscv64_ARCH_GCC_TC="riscv64"
riscv64_ARCH_GCC_FLAGS=""

aarch64_ARCH_SHORT="aarch64"
aarch64_ARCH_FAMILY="arm"
aarch64_ARCH_ELF_NAME="elf64-littleaarch64"
aarch64_ARCH_LD_OUTPUT="aarch64elf"
aarch64_ARCH_GCC_TC="aarch64"
aarch64_ARCH_GCC_FLAGS=""

function set_arch_gcc_tc_arch {

   local name="${1}_ARCH_GCC_TC"
   local value=${!name}

   if [[ "$value" == "" ]]; then
      echo "ERROR: TARGET arch '$1' is NOT supported."
      exit 1
   fi

   ARCH_GCC_TC=$value
}

function set_host_arch_variable {

   HOST_ARCH="`uname -m`"

   if [[ "$HOST_ARCH" == "x86_64" ]]; then

      : # Great, that's our DEFAULT host architecture: do nothing

   elif [[ "$HOST_ARCH" == "amd64" ]]; then

      # An alias for x86_64: fix our variable
      HOST_ARCH="x86_64"

   elif [[ "$HOST_ARCH" == "aarch64" ]]; then

      : # That's OK: no translation necessary.

   else

      echo "ERROR: build host architecture $HOST_ARCH not supported"
      exit 1
   fi
}

# $1 = arch
function set_gcc_tc_defaults_internal {

   # Default GCC toolchain version to use. Unfortunately, it depends on the
   # target architecture, because the list of available pre-built toolchains
   # on https://toolchains.bootlin.com depends on the architecture.

   local f

   for f in default_ver min_ver; do
      if ! [ -f $GCC_TC_CONF/$1/$f ]; then
         echo "ERROR: file $GCC_TC_CONF/$1/$f not found"
         exit 1
      fi
   done

   local name=${1}_DEFAULT_GCC_TC_VERSION
   local value=$(cat $GCC_TC_CONF/$1/default_ver)
   eval "$name=$value"

   local name=${1}_MIN_GCC_TC_VERSION
   local value=$(cat $GCC_TC_CONF/$1/min_ver)
   eval "$name=$value"
}

function set_gcc_tc_defaults {

   local arch
   local var_name

   for arch in ${ALL_ARCH_LIST[@]}; do
      set_gcc_tc_defaults_internal $arch
   done

   local list=()
   list+=(DEFAULT_GCC_TC_VERSION)
   list+=(MIN_GCC_TC_VERSION)

   for var_name in ${list[@]}; do
      local arch_name=${ARCH}_${var_name}
      eval "${var_name}=${!arch_name}"
   done
}

# $1 = arch
function set_gcc_ver_internal {

   local name="${1}_GCC_TC_VER"

   if [[ "${!name}" == "" ]]; then
      local name2="${1}_DEFAULT_GCC_TC_VERSION"
      eval "$name=${!name2}"
   fi

   if [[ "${!name}" == "" ]]; then
      echo "ERROR: ${name}_GCC_TC_VER is not set"
      exit 1
   fi
}

function set_gcc_ver {

   # If the GCC_TC_VER env variable is set, it refers to $ARCH, so set
   # that instance of GCC_TC_VER, so that the internal function won't
   # override it.

   local name
   local name_
   local pfx
   local arch
   local ver   # e.g. 1.2.3
   local ver_  # e.g. 1_2_3
   local val

   if [[ "$GCC_TC_VER" != "" ]]; then

      name="${ARCH}_GCC_TC_VER"
      eval "$name=$GCC_TC_VER"

      if [[ "$ARCH" == "i386" || "$ARCH" == "x86_64" ]]; then
         # Special case for x86: since we're downloading both toolchains
         # also to be used for usax (bootloader), not just for the host
         # apps, it makes sense to force GCC_TC_VER to also apply for the
         # other architecture. In general case (e.g. riscv64, aarch64) that
         # won't happen, as we need only *one* GCC toolchain for usax and
         # one for the host apps.
         i386_GCC_TC_VER=$GCC_TC_VER
         x86_64_GCC_TC_VER=$GCC_TC_VER
      fi
   fi

   for arch in ${ALL_ARCH_LIST[@]}; do

      set_gcc_ver_internal $arch

      name="${arch}_GCC_TC_VER"
      name_="${arch}_GCC_TC_VER_"

      ver=${!name}
      ver_=$(echo $ver | sed -E 's/[.]/_/g')
      eval "${name_}=$ver_"

      pfx="${arch}_GCC_NAME_PFX"
      val="gcc_${ver_}_${arch}"
      eval "$pfx=$val"

   done

   # Set the base variables use the variant where $arch == $ARCH
   name="${ARCH}_GCC_TC_VER"
   name_="${ARCH}_GCC_TC_VER_"
   pfx="${ARCH}_GCC_NAME_PFX"

   eval "GCC_TC_VER=${!name}"
   eval "GCC_TC_VER_=${!name_}"
   eval "GCC_NAME_PFX=${!pfx}"
}

function set_arch_variables {

   local v
   for v in ${ARCH_VARS_LIST[@]}; do
      local name=${ARCH}_ARCH_${v}
      local value=${!name}
      eval "ARCH_${v}='$value'"
   done
}

function set_board_value_and_defaults {

   local found=false

   if [[ "$ARCH" == "riscv64" ]]; then
      ALL_BOARDS_LIST=(qemu-virt licheerv-nano)
      DEFAULT_BOARD="qemu-virt"
   else
      ALL_BOARDS_LIST=()
      DEFAULT_BOARD=""
   fi

   if [[ "$BOARD" == "" ]]; then

      BOARD=$DEFAULT_BOARD

   else

      for b in ${ALL_BOARDS_LIST[@]}; do
         if [[ "$BOARD" == "$b" ]]; then
            found=true
            break
         fi
      done

      if ! $found; then
         echo "ERROR: Board '$BOARD' not available for ARCH: $ARCH"
         exit 1
      fi
   fi

   if [[ "$BOARD" != "" ]]; then
      BOARD_BSP="$MAIN_DIR/other/bsp/$ARCH/$BOARD"
      if ! [ -d $BOARD_BSP ]; then
         echo "ERROR: BOARD_BSP: $BOARD_BSP not found!"
         exit 1
      fi
   fi
}

function dump_build_toolchain_env {

   echo
   echo "ARCH=$ARCH"
   echo "HOST_ARCH=$HOST_ARCH"
   echo "GCC_TC_VER=$GCC_TC_VER"
   echo "MIN_GCC_TC_VERSION=$MIN_GCC_TC_VERSION"
   echo "DEFAULT_GCC_TC_VERSION=$DEFAULT_GCC_TC_VERSION"
   echo "DEFAULT_BOARD=$DEFAULT_BOARD"
   echo "BOARD=$BOARD"
   echo "CC=$CC"
   echo "CXX=$CXX"
   echo
}

